import os, SCons.SConf
from .checks import CheckLibs,CheckLibsWithHeader,CheckSharedLibWithHeader
from . import utils
import platform

class Package:
    """
    Define how to search for an installed package. The steps involved are:
    1. Setup any other packages that are dependencies. 
    2. Setup options specific to this package.
    3. Search for installations. 

    Searching for installations involves generation of a set of configuration
    environments and trying each in turn. The first environment found that
    is able to successfully pass a prespecified test is used.

    The method 'gen_envs' is used to generate the set of environments to
    check. 'check' performs the test. By default 'gen_envs' uses the
    generated locations (see below) and 'check' tries to compile and link
    with any headers and libraries.

    Locations are generated by initially attempting to use command line
    arguments. If any were specified they are used instead of anything else.
    If none were given, a set of locations are tried in order and the first
    successful is used. The method 'gen_locations' is responsible for
    generating this list of locations.

    Locations are specified as a tuple with three entries, as follows:
    (base directory, [header directories], [library directories])
    For example:
    ('/usr/local', ['/usr/local/include'], ['/usr/lib', '/usr/lib64'])
    """

    static = False

    def __init__(self, name, env, **kw):
        self.name = name
        self.env = env
        self.required = kw.get('required', True)
        self.result = None
        self.headers = []
        # We need a list of library paths to ignore.
        self.system_inc_dirs = [os.path.normpath('/usr/include'),
                                os.path.normpath('/usr/local/include')]
        self.system_lib_dirs = [os.path.normpath('/usr/lib'),
                                os.path.normpath('/usr/lib/i386-linux-gnu'),
                                os.path.normpath('/usr/lib/x86_64-linux-gnu'),
                                os.path.normpath('/usr/lib/amd64-linux-gnu'),
                                os.path.normpath('/usr/lib64'),
                                os.path.normpath('/usr/local/lib'),
                                os.path.normpath('/usr/local/lib64')]
        # Setup the dependencies and options.
        self.setup_dependencies()
        self.setup_options()

    def setup_dependencies(self):
        """
        Add any dependency packages with the 'add_dependency' method.
        """
        # self.add_dependency(...)
        pass

    def setup_options(self):
        """
        Add any package specific options to the configuration. By default we
        add options for specifying a base directory, include and library
        directories and libraries.
        """
        from SCons.Script.Main import AddOption
        n = self.name
        ln = n.lower()
        AddOption('--%s-dir'%ln, dest='%s_dir'%ln, nargs=1, type='string',
                  action='store', help='Base directory for %s installation.'%n)
        AddOption('--%s-inc-dir'%ln, dest='%s_inc_dir'%ln, nargs=1, type='string',
                  action='store', help='Directory for %s headers.'%n)
        AddOption('--%s-lib-dir'%ln, dest='%s_lib_dir'%ln, nargs=1, type='string',
                  action='store', help='Directory for %s libraries.'%n)
        AddOption('--%s-libs'%ln, dest='%s_libs'%ln, nargs=1, type='string',
                  action='store', help='%s libraries.'%n)

    def gen_locations(self):
        yield None

    def gen_base_extensions(self):
        #OK, 5/2011 - added multiarch lib paths for ubuntu 11.04
        yield (['include'], ['lib'])
        yield (['include'], ['lib/i386-linux-gnu'])
        yield (['include'], ['lib/x86_64-linux-gnu'])
        yield (['include'], ['lib/amd64-linux-gnu'])
        yield (['include'], ['lib64'])

    def gen_envs(self, loc):
        """
        Generate environments modified to include options required for
        using this package. Each yielded environment should be cloned
        from the one stored on the class ('self.env') so as to preserve
        the original.

        By default we just include the location passed in
        as include paths, library paths and rpaths.
        """
        env = self.env.Clone()
        env.AppendUnique(CPPPATH=[l for l in loc[1] if l not in self.system_inc_dirs])
        env.AppendUnique(LIBPATH=[l for l in loc[2] if l not in self.system_lib_dirs])
        env.AppendUnique(RPATH=[l for l in loc[2] if l not in self.system_lib_dirs])
        yield env

    def check(self, conf, env):
        """
        Try a basic check to see if the current environment is valid. Use
        'self.headers' as a list of headers to try to include in the
        compile.
        """
        result = conf.CheckLibWithHeader(None, self.headers, 'c', autoadd=0)
        if not result:
            result = conf.CheckLibWithHeader(None, self.headers, 'c++', autoadd=0)
        return result

    def __call__(self, **kw):
        self.env = kw.get('env', self.env)

        # Don't run twice.
        if self.result is not None:
            return self.env

        # Process dependencies.
        if hasattr(self, 'deps'):
            for d in self.deps:
                d()

        # Check for overrides.
        if 'required' in kw:
            self.required = kw['required']

        # Show an initial message.
        SCons.SConf.progress_display('Checking for package %s... '%self.name,
                                     append_newline=0)

        # Switch off intermediate display.
        SCons.SConf.progress_display.set_mode(0)

        # Initialise the result to False.
        self.result = False

        for loc in self._gen_locations():

            # Stash on the package.
            self.location = loc

            for env in self.gen_envs(loc):

                # Setup the  environment.
                conf = env.Configure(
                    custom_tests={
                        'CheckLibs': CheckLibs,
                        'CheckLibsWithHeader': CheckLibsWithHeader,
                        'CheckSharedLibWithHeader': CheckSharedLibWithHeader
                        }
                    )

                # Run the checks and remove temporary header variable.
                self.result = self.check(conf, env)

                # If successful, export a definition.
                if self.result:
                    env.AppendUnique(CPPDEFINES=['HAVE_' + self.name.upper()])

                # Finish the check.
                conf.Finish()
                if self.result:
                    break

            if self.result:
                break

        # Reset the display.
        SCons.SConf.progress_display.set_mode(1)
        res = self.result and 'yes' or 'no'
        SCons.SConf.progress_display(res)

        # If this package was required and it failed print out a message.
        if not self.result and self.required:
            print('****  ERROR ****')
            print('Failed to locate required package %s.'%self.name)
            print('Details in \'config.log\'')
            self.env.UWExit()

        # If successful, update the original environment.
        if self.result:
            self.env._dict.update(env._dict)

        return self.result

    def add_dependency(self, mod, **kw):
        if not hasattr(self, 'deps'):
            self.deps = []
        self.deps.append(self.env.UsePackage(mod, **kw))
        return self.deps[-1]

    def get_option(self, name):
        # First check command line.
        val = self.env.GetOption(name)
        if not val:
            # Now check environment.
            return os.environ.get(name.upper(), None)
        return val

    def find_libraries(self, dirs, libs):
        # If no directories were given, return failure.
        if not dirs:
            return None

        # Define the prefixes and suffixes for shared and static
        # libraries.
        static_prefixes = ['lib']
        shared_prefixes = ['lib']
        static_suffixes = ['.a']
        shared_suffixes = []
        if platform.system() in ['Linux', 'Darwin']:
            shared_suffixes += ['.so']
        if platform.system() == 'Darwin':
            shared_suffixes += ['.dylib']
        if platform.system().find('CYGWIN') != -1:
            shared_suffixes += ['.dll']
            static_suffixes += ['.dll.a']
        if platform.system() == 'Windows':
            static_prefixes += ['']
            shared_prefixes += ['']
            shared_suffixes += ['.dll']

        libs = utils.conv.to_list(libs)
        static_paths = []
        shared_paths = []
        static_failed = []
        shared_failed = []
        for l in libs:
            cur_static_paths = [p for p in utils.path.find(l, dirs,
                                                           static_prefixes,
                                                           static_suffixes)]
            cur_shared_paths = [p for p in utils.path.find(l, dirs,
                                                           shared_prefixes,
                                                           shared_suffixes)]
            if not cur_static_paths:
                static_paths = None
                static_failed += [l]
            elif static_paths is not None:
                static_paths += cur_static_paths
            
            if not cur_shared_paths:
                shared_paths = None
                shared_failed += [l]
            elif shared_paths is not None:
                shared_paths += cur_shared_paths

        if static_paths is None and shared_paths is None:
            log = open('config.log', 'a')
            log.write('  Failed to find static or shared libraries for %s.\n'%repr(self.name))
            log.write('  Static missing: %s\n'%repr(static_failed))
            log.write('  Shared missing: %s\n'%repr(shared_failed))
            log.write('  Looked in: %s\n'%repr(dirs))
            log.close()
            return None
        return (static_paths, shared_paths)

    def _gen_extended_locations(self, loc):
        for inc, lib in self.gen_base_extensions():
            inc = utils.conv.to_list(inc)
            lib = utils.conv.to_list(lib)
            # Figure out which include and library paths to use.
            if loc[1]:
                if inc:
                    inc = sum([[os.path.join(p, i) for i in inc] for p in loc[1]], [])
                else:
                    inc = loc[1]
            elif loc[0]:
                inc = [os.path.join(loc[0], i) for i in inc]
            else:
                inc = []
            if loc[2]:
                if lib:
                    lib = sum([[os.path.join(p, l) for l in lib] for p in loc[2]], [])
                else:
                    lib = loc[2]
            elif loc[0]:
                lib = [os.path.join(loc[0], l) for l in lib]
            else:
                lib = []
            # Yield the new location.
            yield (loc[0], inc, lib)

    def _gen_locations(self):
        ln = self.name.lower()

        # If we were given a base directory try that.
        base = self.get_option(ln + '_dir')
        if base:
            # Generate all the extensions by passing in a location with no
            # entries in the include and library paths.
            for loc in self._gen_extended_locations((base, [], [])):
                yield loc

        else:
            # If we were given an include and library dir,
            # use that instead.
            inc_dir = self.get_option(ln + '_inc_dir')
            lib_dir = self.get_option(ln + '_lib_dir')
            if inc_dir and lib_dir:
                yield ('', [inc_dir], [lib_dir])

            else:
                # Try a set of default locations for this system.
                bases = []
                if platform.system() in ['Linux', 'Darwin'] or platform.system().find('CYGWIN') != -1:
                    bases += ['/usr', '/usr/local']
                if platform.system() == 'Darwin':
                    bases += ['/sw', '/opt/local']
                if platform.system() == 'Windows':
                    pass
                for b in bases:
                    for loc in self._gen_extended_locations((b, [], [])):
                        yield loc
                # Finally try an empty search followed by locations
                # specific to the package.
                for loc in self.gen_locations():
                    if loc is None:
                        continue
                    # Try the generated location on its own first.
                    yield loc
                    # Fill in any empty entries by expanding the
                    # base directory extensions.
                    for l in self._gen_extended_locations(loc):
                        yield l

    def pull_from_git(self, git_repo, git_branch_tag, target_directory, logfile=None):
        if not logfile:
            import os
            logfile = open(os.devnull, 'w')
        import subprocess
        subp = subprocess.Popen('mkdir -p {}'.format(target_directory), shell=True, stdout=logfile, stderr=logfile)
        subp.wait()
        if subp.wait() != 0:
            raise RuntimeError("There appears to have been an error creating the directory: {}".format(target_directory))

        subp = subprocess.Popen('cd {};' \
                                'git init;' \
                                'git remote add origin {};' \
                                'git fetch;' \
                                'git reset origin/master;' \
                                'git checkout .;' \
                                'git checkout -f {};' \
                                'git submodule update --init;'.format(target_directory, git_repo, git_branch_tag), shell=True, stdout=logfile, stderr=logfile)
        subp.wait()
        if subp.wait() != 0:
            raise RuntimeError("There appears to have been an error relating to a git repo creation.")


